---
layout: post
title: Совершенный код, ч.1 
---
# {{page.title}} (_Макконнелл С. - Code Complete_)

<blockquote>
За время, которое вы потратите на чтение текста ниже, можно развернуть до пяти сайтов на вордпресс или объявить около двадцати фабрик. 
</blockquote>


Сразу скажу — я горячий сторонник всяких [programming mothefucker](http://programming-motherfucker.com/). Сейчас модно не называть программирование программированием, но если взять и разложить это для семилетнего, то окажется, что в этой среде есть слишком разные люди. Есть спортивное программирование, когда пацанчики на спорте ебашат задачи, используя знания алгоритмов и математики; они как турникомены с 6 лет делают выход силы по вечерам и утренний подъем с переворотом. Есть хакеры — когда задачи реальные, а правил, в общем-то нет, кроме чести — эти ребята якобы не знают слова невозможно, поэтому так симпатичны для голливуда и 12-летних подростков. А вот дяди, которые потеют за то, чтобы у них регулярно, два раза в месяц, обновлялись цифры в базе данных платежных систем — промышленные программисты. А по вечерам, когда эти дяди едут домой, слушая подкасты, они смотрят в запотевшее окно и мечтают о том, как сделают библиотеку с тысячью звездочками на гитхабе.

И что мне не нравится в таких книгах, это когда я вижу вот такие диаграммы: ![Глава 1, Процессы конструирования](/img/cc/1.jpg). Недостаток внутрннего академического воспитания и силы воли, но такая скука.

![Глава 1, Кодирование и отладка](/img/cc/2.jpg)

Однако, уже второй рисунок всё меняет. Кодирование и отладка! В конце концов, у Стива Макконнелла чувствуется боль, которую невозможно заглушить маленькой книжечкой, поэтому он написал здоровенный тяжелый кирпич, которым можно было бы приговорить плохого программиста на месте.

## Глава 2

Первая осмысленная глава. “Метафоры, позволяющие лучше понять разработку ПО”. Сначала метафора литературная, она описывает, конечно, в какой-то мере небольшие проекты: сел такой и написал код на хакатоне. Слишком примитивная, говорит автор, код, в отличие от книги не будет законченным. ОТКАЗАТЬ.

Та метафора, в которой софт это взращивание картошки, включая подготовку, поливку, прополку, удобрения и очень многие этапы — сельскохозяйственная. Есть опасность начать говорить про “надо проредить проект” и “сдобрить его новым ~~навозом~~ библиотеками”. Я не могу повлиять на картошку напрямую, тогда как на код могу и поэтому ОТКАЗАТЬ. 

Фантазия людей, что ты делаешь, и следующей выступает метафора жемчужины. Инкрементная разработка наращиванием. Сначала создаем скелет, прототип, потом начинаем по слоям. Читайте Фред Брукс “Мифический человеко-месяц”, пишет автор и даёт  ДОБРО. 

Самая популярная метафора, которой нашлось место даже на башорге, это строительная. Очень много аналогий. Хотите перенести стену? Тратится время рабочих на перепроектировку. Что-то можно поменять уже в построенном доме, сделать капитальный ремонт, но зачастую проще построить новый дом. И никто не будет создавать вещи, которые можно купить (стиральную машину, базу данных, шкаф, фреймворк), только если это не индивидуальный, особенный проект, под особые деньги. ДОБРО.

Но как обычно, мир не черный и белый, а между ними все 50 оттенков серого (через год выйдет фильм, я получу свои 100 посетителей!). Комибинируйте метафоры, меняйте их, пользуйтесь этими эвристическими аналогиями, смело придумывайте новые аналогии с друзьями, используя бульбулятор (а ведь это тоже метафора).

Эта вторая глава мне не понравилась как раз заключением, после того как автор протащил нас через такую череду рассуждений, он как бы извиняется, простите, что толку от этого почти нет. Посыл простой — не можешь обьяснить напрямую, пользуйся аналогиями, понятными собеседнику.

## Глава 3. Про предварительные условия.

Глава открывается поговоркой про плотников "Measure Twice, Cut Once". В русской версии книги это уже «Семь раз отмерь — один раз отрежь». В индийской версии я не проверял, то бы подошло «Отмеряй вечность, пока не сотрется метр» на хинди. И дальше глава говорит как важно, как важно соблюдать все эти условия.

В наш век, когда на первый план людских глаз выходит софт, написанный ночью за выпитыми литрами кофе, создается впечатление, что вся эта штука с проектированием — пустая суета. Конечно, это так, ведь 90% рынка софта остается за пределами видимости среднего уличного кодера-микроблоггера. От NASA до медицины — там всё по-старому.

Люди не знакомые с разработкой ПО могут болеть синдромом WISCA: «Why Isn’t Sam Coding Anything? (Почему Сэм не пишет код?)». Тут на помощь приходят метафоры, помните. Стройка ещё не началась, даже фундамента нет — все сидят и чертят планы здания и всё согласуют! Поэтому автор приводит пару аргументов: обращение к логике, обращение к аналогиям, обращение к статистики из прошлого. Чем раньше исправляется ошибка, тем дешевле это стоит. 

А теперь снова моя нелюбимая часть, “всё зависит от проекта”. Конечно, К.О. Пишешь сайты если ты, то тебе даже Стив советует “нечеткую спецификацию требований”. Ни предварительное проектирование, ни комбинация итеративного подхода к исправлению ошибок не может дать однозначных гарантий, но всё-таки для большинства типов проектов можно вывести какие-то рекомендации. 

Все рекоменндации вкратце звучат так “Суть предварительных условий конструирования в том, что вам следует сначала определить, какие из них уместны для вашего проекта.”. Вот вам картинка, будто бы из рассылки очередного психологического тренинга, который откроет вам глаза:

![Глава 3, Пирамида](/img/cc/3.jpg)

Первое — это определение проблемы. Не решения, а проблемы. Чувствуете разницу? Если плохо сформуровать проблему, можно потратить время, решая не ту.
Второе — требования. Не программистом, а заказчиком. 

<blockqoute>
Требования подобны воде. Опираться на них легче, если они заморожены.
Аноним
</blockqoute>

Затем идут советы. Когда читаешь такие советы не видишь противоречий. Но и откровений тоже. Но если у вас в проекте постоянно меняются требования посмотрите страницу 39. Там даже приведен контрольный список вопросов. Типа “можно ли провести независимое тестирование, которое определит, что выполнены все требования”. 

В описании правильной архитектуры сквозит ООП подход. Классы, методы. Стандартные слова, что GUI должен быть GUI, масштабирование, безопасность и всё такое. Отличная копипаста в коммерческие предложения и тендеры. 

## Глава 4. Основные решения, которые приходится принимать при конструировании

Вот есть требования. И что дальше? Выбор языков программирования. Это смешно. Jбосновнные специальным научным трудом и моделью оценки Cocomo II фразы в духе “если опыт с языком три года, эффективность выше на 30%, чем у тех, для кого язык новый” звучат хорошо только для руководителей. Стив наверняка выполнял какую-то задачу по минимальному объему текста, который корпоративные инженеры должны использовать в своих письмах руководителям и кадровикам. Особенно мне понравилась вот эта таблица:

![Глава 4, таблица](/img/cc/4.jpeg)

Пример такой: если писал всю жизнь на Visual Basic (Fortran), то и на C++ будешь писать так же, перенеся туда всю свою быдлячью деревенскую сущность. Описание языков тоже довольно устаревшее, зато это та самая “старая школа”, хардкор. Не забыть про конвекцию. И снова на помощь приходит метафора “одна часть картины в стиле импрессиониста, другая в классическом, третья в кубическом? — что получится в итоге”. А в итоге получится шедевр.

Какой софт купить, какую платформу выбрать и еще сто очевидных вопросов. Составить анкету и следовать ей — это корпоративный стиль. Представьте себе разработку операционной системы для x-box. Представьте себе программные комплексы в самолете. Ну и наконец, какой-нибудь Netflix. Вот когда вас будет десять человек с многолетним опытом, чтобы спроектировать систему — тогда вам может и пригодится этот список. Так закончилась эта невзрачная часть. 

## Часть II. Высококачественный код
## Глава 5. Проектирование при конструировании

<blockquote>
Проектирование — недетерминированный процесс
</blockquote>

Как мне нравится пафосное название этой части. Эти два слова не услышишь в реальной жизни, кроме как в резюме Senior Java Developer. 

Грязная проблема — проблема, которая возникает при частичном или полном решении другой проблемы. Иногда приходится что-то сделать, чтобы понять что надо сделать, чтобы в итоге решить задачу. Проектирование недетерминировано, связано с ограничениями, и, наконец, вывод — проектирование это эвристический процесс. Дальше идет такая скукота, что мне пришлось поставить три последовательных будильника, но я всё равно отключился. Система делится на подсистемы, те делятся на классы, а потом на методы. ВОТ ЭТО ДА.

Но с другой стороны, чем больше явных деталей собраны вместе в этой главе, тем легче выровнять средний опыт, её читающих. Представьте, что каждому из них задан вопрос “Как делать софт?”. Каждый вспомнит процентов 60% из этой главы. Поэтому вот вам 100%, читайте и запоминайте.

Манипулируйте абстракциями, смело кидайте инкапсуляции в лицо всем объектам, живите композицией. Абстракция говорит: «Вы можете рассмотреть объект с общей точки зрения». Инкапсуляция добавляет: «Более того, вы не можете рассмотреть объект с иной точки зрения»

Снова ничего полезного. Меня разочаровывает эта глава. Она слишком привязана к ООП. “Используйте наследование, если оно облегчает проектирование”. Полиморфизм? 

Сокрытие информации - вот важный столб программирования. Не доверяй никому Вместо id = ++ currentID вы пишете метод NewID() и он возвращает вам всё, как вы пожелаете. Выделите области, которые меняются и изолируйте их (приведу хоть один список, чтобы вы поняли что вся книга именно в подобных списках):

- Бизнес правила;
- Зависимости от оборудования;
- Ввод-вывод;
- Нестандартные возможности языка;
- Сложные аспекты проектирования и конструирования.

Нужно уменшать сопряжение (не связанность, это другое), которое бывает нескольких видов (через объект, параметры, семантичекое). И вот тут реально хорошие примеры приведены. 

Используйте шаблоны проектирования, шаблоны известные всем. Это выиграет вам 10 минут на интервью, в течение которых HR поставит вам две галочки. 

Формализуйте контракты классов, проектируйте систему для тестирования. Затем следуют два разных совета. Один звучит как “избегайте неудач” (спасибо!), а второй “тщательно выбирайте время связывания” (binding time). Если в коде есть `x = 3`, то чем позже будет `x = 3`, тем лучше. Я тоже за pure functional way, lazy, нас этому ещё на физике учили, чтобы это не значило!

Когда написал что-то, хочется переписать заново (только не этот пост), чтобы стало лучше, стремится к совершенству, это слово неслучайно присуствует в заголовке книги (complete). Многое на своей шкуре почувствал, понял где вляпался и теперь по ночам мучает совесть. Хочется сделать новую ветку, в которой от старого ничего, даже README. Тоже самое с проектированием — итерации рулят. Можно идти сверху, но если сверху идти очень сложно и абстрактно для человеческого разума, начинают снизу. Совместное проектирование за чашкой кофе или максимально формализованное. Если некому помочь — можно помочь самому себе, правой или левой рукой, как вы больше любите. Описываем, сохраняем всё и возвращаемся через неделю. Трезвый взгляд помогает.

В этой же главе дальше идёт критика проектирования и крайне полезная литература, которую никто не будет читать.

## Глава 6

Наконец-то господа. Наконец-то. Начинается самое интересное. Самое интересное начинается с самого абстрактного: абстрактных типов данных (Abstract data type). Всякие графы, мапы, хэши, стеки и прочее. Независимо от того, императивный или функциональный стиль.

Выражайте в интерфейсе класса согласованный уровень абстракции

Абстракция, формируемая этими методами, относится к уровню «employee» (сотрудник).
 void AddEmployee( Employee employee );
 void RemoveEmployee( Employee employee );
Абстракция, формируемая этими методами, относится к уровню «list» (список).
 Employee NextItemInList();
 Employee FirstItem();

Здесь ListContainer смешивается с Employers. Поэтому лучше — разносить. Надо понимать реализации какой абстракции является класс. 
Инкапсулируйте говорит нам книга с таким примером:
float x;
float y;
float z;
нарушает инкапсуляцию, потому что клиентский код может свободно делать с
данными Point что угодно, при этом сам класс может даже не узнать об их изме#
нении (Riel, 1996). В то же время класс Point, включающий члены:
float GetX();
float GetY();
float GetZ();
void SetX( float x );
void SetY( float y );
void SetZ( float z );

Чувствуете C++ прошлого тысячелетия? Наверное, мне досталось старая версия книги или много занудства. Как же от этого тошнит. Но в общем и целом, это правда. Интерфейсы полезны, употребляйте их почаще. Минимизируйте доступность классов и методов. И так далее. И тому подобное. Предоставьте, что вы разрабатываете большое SDK. И посмотрите на хорошие примеры.
Не «переопределяйте» непереопределяемые методы'члены. 
Убедитесь, что вы наследуете только то, что хотите наследовать.
Перемещайте общие интерфейсы, данные и формы поведения на как можно более высокий уровень иерархии наследования.
С подозрением относитесь к классам, объекты которых создаются в единственном экземпляре.
С подозрением относитесь к базовым классам, имеющим только один производный класс

Пример. С подозрением относитесь к классам, которые переопределяют метод,
оставляя его пустым Как правило, это говорит о неудачном проектировании
базового класса. Допустим, вы создали класс Cat, включающий метод Scratch()
(царапать), но после обнаружили, что некоторые коты лишены когтей и не могут
царапаться. Вы могли бы унаследовать от класса Cat класс ScratchlessCat, переоп#
ределив в нем метод Scratch() так, чтобы он ничего не делал. Однако этот подход
связан с рядом проблем.
Он нарушает абстракцию (контракт интерфейса) класса Cat, изменяя семан#
тику его интерфейса.
При расширении на другие производные классы этот подход быстро стано#
вится неуправляемым. Что будет, когда вы найдете кота без хвоста? Или кота,
который не ловит мышей? Или кота, который не пьет молоко? В итоге у вас
могут появиться производные классы вроде ScratchlessTaillessMicelessMilklessCat.
Код, написанный по этой методике, трудно сопровождать, потому что со вре#
менем поведение производных классов начинает сильно отличаться от интер#
фейсов и форм поведения базовых классов.
Исправлять эту проблему следует не в базовом классе, а в первоначальном классе
Cat. Создайте класс Claws (когти) и включите его в класс Cats. Корень наших бед
— предположение, что все коты царапаются; предложенный способ позволит
устранить причину проблемы, а не бороться с ее следствиями.

Вообще минимизируйте сотрудничество класса с другими классами Старайтесь свести к минимуму все следующие показатели:
число видов создаваемых объектов;
число непосредственно вызываемых методов созданных объектов;
число вызовов методов, принадлежащих объектам, возвращенным другими
созданными объектами.

Резюме причин создания класса
Вот список разумных причин создания класса:
моделирование объектов реального мира;
моделирование абстрактных объектов;
снижение сложности;
изоляция сложности;
сокрытие деталей реализации;
ограничение влияния изменений;
сокрытие глобальных данных;
упрощение передачи параметров в методы;
создание центральных точек управления;
облегчение повторного использования кода;
планирование создания семейства программ;
упаковка родственных операцией;
выполнение специфического вида рефакторинга.


Глава 7. Высококачественные методы

Что это ещё за ерунда, “высококачественные методы”? Это всё, начиная от плохо названного метода, когда название ниочем не говорит, до заветного числа 7 (не должно быть больше семи входных параметров и семи операций). На языках вроде Haskell большая часть рекомендаций соблюдается by design. Ну и вообще современные языки вкупе с современными IDE позволяют легко контролировать сложность методов, не говоря о форматировании. Например, любой линтер, статический анализатор (или какая-нибудь IDEA и Visual Studio) предупредит о неиспользуемых переменных и тому подобных вещах, которые приведены в главе.
Метод в императивных языках нужно создавать, чтобы документировать код. И соблюдать принцип DRY. В книге об этом не сказано, но в ФП всё немного по другому. Иммутабельные чистые функции пишутся там сами. Мемоизация, легкость отладки, ну и просто сама концепция заставляет.
Далее идет “удачное имя метода”, При функциональном связывании, когда один метод - одна функция. Я понял откуда все эти длинные названия в корпоративных системах. В том числе из этой книги. Современные IDE позволяют автокомплит, поэтому можно написать три символа, остальные двадцать добьет редактор.
Объем метода, его параметры. Все эти рекомендации есть в вашем code conventions. Поищите.
Когда использовать функцию а когда процедуру? Ответа тоже нет. Используйте функцию, если это функция.

