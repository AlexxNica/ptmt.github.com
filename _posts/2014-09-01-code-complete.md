---
layout: post
title: Совершенный код, ч.1 
---
# {{page.title}} (_Макконнелл С. - Code Complete_)

<blockquote>
За время, которое вы потратите на чтение текста ниже, можно развернуть до пяти сайтов на вордпресс или объявить около двадцати фабрик. 
</blockquote>


Сразу скажу — я горячий сторонник всяких [programming mothefucker](http://programming-motherfucker.com/). Модно не называть программирование программированием, но попытаясь разложить это для семилетнего,  окажется, что в этой среде есть очень разные цели. Есть спортивное программирование, когда пацанчики на спорте ебашат задачи, используя знания алгоритмов и математики; они как турникомены с 6 лет делают выход силы по вечерам и утренний подъем с переворотом. Есть хакеры — когда задачи реальные, а правил, в общем-то нет — эти ребята якобы не знают слова невозможно, поэтому так симпатичны для голливуда и 14-летнего меня. А вот дяди, которые потеют за то, чтобы у них регулярно, два раза в месяц, обновлялись цифры в базе данных платежных систем — промышленные программисты. А по вечерам, когда эти дяди едут домой, слушая подкасты, они смотрят в запотевшее окно и мечтают о том, как сделают библиотеку с тысячью звездочками на гитхабе.

И что мне не нравится в таких книгах, это когда я вижу вот такие диаграммы: ![Глава 1, Процессы конструирования](/img/cc/1.png)

Недостаток внутрннего академического воспитания и силы воли у меня, конечно, но — такая скука!

![Глава 1, Кодирование и отладка](/img/cc/2.png)

Однако, уже второй рисунок всё меняет. Кодирование и отладка! В конце концов, через текст Стива Макконнелла чувствуется боль, которую невозможно было заглушить маленькой книжечкой, поэтому Стив написал здоровенный тяжелый кирпич, которым можно было бы приговорить плохого программиста на месте.

## Глава 2

Первая осмысленная глава. “Метафоры, позволяющие лучше понять разработку ПО”. Сначала метафора литературная, она описывает, конечно, в какой-то мере небольшие проекты: сел такой и написал код на хакатоне. Слишком примитивная, говорит автор, код, в отличие от книги не будет законченным. ОТКАЗАТЬ.

Та метафора, в которой софт это взращивание картошки, включая подготовку, поливку, прополку, удобрения и очень многие этапы — сельскохозяйственная. Есть опасность начать говорить про “надо проредить проект” и “сдобрить его новым ~~навозом~~ библиотеками”. Я не могу повлиять на картошку напрямую, тогда как на код могу и поэтому ОТКАЗАТЬ. 

Фантазия людей, что ты делаешь, и следующей выступает метафора жемчужины. Инкрементная разработка наращиванием. Сначала создаем скелет, прототип, потом начинаем по слоям. Читайте Фред Брукс “Мифический человеко-месяц”, пишет автор и даёт  ДОБРО. 

Самая популярная метафора, которой нашлось место даже на башорге, это строительная. Очень много аналогий. Хотите перенести стену? Тратится время рабочих на перепроектировку. Что-то можно поменять уже в построенном доме, сделать капитальный ремонт, но зачастую проще построить новый дом. И никто не будет создавать вещи, которые можно купить (стиральную машину, базу данных, шкаф, фреймворк), только если это не индивидуальный, особенный проект, под особые деньги. ДОБРО.

Но как обычно, мир не черный и белый, а между ними все 50 оттенков серого (через год выйдет фильм, я получу свои 100 посетителей!). Комибинируйте метафоры, меняйте их, пользуйтесь этими эвристическими аналогиями, смело придумывайте новые аналогии с друзьями, используя бульбулятор (а ведь это тоже метафора).

Эта вторая глава мне не понравилась как раз заключением, после того как автор протащил нас через такую череду рассуждений, он как бы извиняется, простите, что толку от этого почти нет. Посыл простой — не можешь обьяснить напрямую, пользуйся аналогиями, понятными собеседнику.

## Глава 3. Про предварительные условия.

Глава открывается поговоркой про плотников "Measure Twice, Cut Once". В русской версии книги это уже «Семь раз отмерь — один раз отрежь». В индийской версии я не проверял, то бы подошло «Отмеряй вечность, пока не сотрется метр» на хинди. И дальше глава говорит как важно, как важно соблюдать все эти условия.

В наш век, когда на первый план людских глаз выходит софт, написанный ночью за выпитыми литрами кофе, создается впечатление, что вся эта штука с проектированием — пустая суета. Конечно, это так, ведь 90% рынка софта остается за пределами видимости среднего уличного кодера-микроблоггера. От NASA до медицины — там всё по-старому.

Люди не знакомые с разработкой ПО могут болеть синдромом WISCA: «Why Isn’t Sam Coding Anything? (Почему Сэм не пишет код?)». Тут на помощь приходят метафоры, помните. Стройка ещё не началась, даже фундамента нет — все сидят и чертят планы здания и всё согласуют! Поэтому автор приводит пару аргументов: обращение к логике, обращение к аналогиям, обращение к статистики из прошлого. Чем раньше исправляется ошибка, тем дешевле это стоит. 

А теперь снова моя нелюбимая часть, “всё зависит от проекта”. Конечно, К.О. Пишешь сайты если ты, то тебе даже Стив советует “нечеткую спецификацию требований”. Ни предварительное проектирование, ни комбинация итеративного подхода к исправлению ошибок не может дать однозначных гарантий, но всё-таки для большинства типов проектов можно вывести какие-то рекомендации. 

Все рекоменндации вкратце звучат так “Суть предварительных условий конструирования в том, что вам следует сначала определить, какие из них уместны для вашего проекта.”. Вот вам картинка, будто бы из рассылки очередного психологического тренинга, который откроет вам глаза:

![Глава 3, Пирамида](/img/cc/3.png)

Первое — это определение проблемы. Не решения, а проблемы. Чувствуете разницу? Если плохо сформуровать проблему, можно потратить время, решая не ту.
Второе — требования. Не программистом, а заказчиком. 

<blockquote>
Требования подобны воде. Опираться на них легче, если они заморожены.
Аноним
</blockquote>

Затем идут советы. Когда читаешь такие советы не видишь противоречий. Но и откровений тоже. Но если у вас в проекте постоянно меняются требования посмотрите страницу 39. Там даже приведен контрольный список вопросов. Типа “можно ли провести независимое тестирование, которое определит, что выполнены все требования”. 

В описании правильной архитектуры сквозит ООП подход. Классы, методы. Стандартные слова, что GUI должен быть GUI, масштабирование, безопасность и всё такое. Отличная копипаста в коммерческие предложения и тендеры. 

## Глава 4. Основные решения, которые приходится принимать при конструировании

Вот есть требования. И что дальше? Выбор языков программирования. Это смешно. Jбосновнные специальным научным трудом и моделью оценки Cocomo II фразы в духе “если опыт с языком три года, эффективность выше на 30%, чем у тех, для кого язык новый” звучат хорошо только для руководителей. Стив наверняка выполнял какую-то задачу по минимальному объему текста, который корпоративные инженеры должны использовать в своих письмах руководителям и кадровикам. Особенно мне понравилась вот эта таблица:

![Глава 4, таблица](/img/cc/4.png)

Пример такой: если писал всю жизнь на Visual Basic (Fortran), то и на C++ будешь писать так же, перенеся туда всю свою быдлячью деревенскую сущность. Описание языков тоже довольно устаревшее, зато это та самая “старая школа”, хардкор. Не забыть про конвекцию. И снова на помощь приходит метафора “одна часть картины в стиле импрессиониста, другая в классическом, третья в кубическом? — что получится в итоге”. А в итоге получится шедевр.

Какой софт купить, какую платформу выбрать и еще сто очевидных вопросов. Составить анкету и следовать ей — это корпоративный стиль. Представьте себе разработку операционной системы для x-box. Представьте себе программные комплексы в самолете. Ну и наконец, какой-нибудь Netflix. Вот когда вас будет десять человек с многолетним опытом, чтобы спроектировать систему — тогда вам может и пригодится этот список. Так закончилась эта невзрачная часть. 

## Часть II. Высококачественный код
## Глава 5. Проектирование при конструировании

<blockquote>
Проектирование — недетерминированный процесс
</blockquote>

Как мне нравится пафосное название этой части. Эти два слова не услышишь в реальной жизни, кроме как в резюме Senior Java Developer. 

Грязная проблема — проблема, которая возникает при частичном или полном решении другой проблемы. Иногда приходится что-то сделать, чтобы понять что надо сделать, чтобы в итоге решить задачу. Проектирование недетерминировано, связано с ограничениями, и, наконец, вывод — проектирование это эвристический процесс. Дальше идет такая скукота, что мне пришлось поставить три последовательных будильника, но я всё равно отключился. Система делится на подсистемы, те делятся на классы, а потом на методы. ВОТ ЭТО ДА.

Но с другой стороны, чем больше явных деталей собраны вместе в этой главе, тем легче выровнять средний опыт, её читающих. Представьте, что каждому из них задан вопрос “Как делать софт?”. Каждый вспомнит процентов 60% из этой главы. Поэтому вот вам 100%, читайте и запоминайте.

Манипулируйте абстракциями, смело кидайте инкапсуляции в лицо всем объектам, живите композицией. Абстракция говорит: «Вы можете рассмотреть объект с общей точки зрения». Инкапсуляция добавляет: «Более того, вы не можете рассмотреть объект с иной точки зрения»

Снова ничего полезного. Меня разочаровывает эта глава. Она слишком привязана к ООП. “Используйте наследование, если оно облегчает проектирование”. Полиморфизм? 

Сокрытие информации - вот важный столб программирования. Не доверяй никому Вместо id = ++ currentID вы пишете метод NewID() и он возвращает вам всё, как вы пожелаете. Выделите области, которые меняются и изолируйте их (приведу хоть один список, чтобы вы поняли что вся книга именно в подобных списках):

- Бизнес правила;
- Зависимости от оборудования;
- Ввод-вывод;
- Нестандартные возможности языка;
- Сложные аспекты проектирования и конструирования.

Нужно уменшать сопряжение (не связанность, это другое), которое бывает нескольких видов (через объект, параметры, семантичекое). И вот тут реально хорошие примеры приведены. 

Используйте шаблоны проектирования, шаблоны известные всем. Это выиграет вам 10 минут на интервью, в течение которых HR поставит вам две галочки. 

Формализуйте контракты классов, проектируйте систему для тестирования. Затем следуют два разных совета. Один звучит как “избегайте неудач” (спасибо!), а второй “тщательно выбирайте время связывания” (binding time). Если в коде есть `x = 3`, то чем позже будет `x = 3`, тем лучше. Я тоже за pure functional way, lazy, нас этому ещё на физике учили, чтобы это не значило!

Когда написал что-то, хочется переписать заново (только не этот пост), чтобы стало лучше, стремиться к совершенству, это слово неслучайно присуствует в заголовке книги (complete). Многое на своей шкуре почувствал, понял где вляпался и теперь по ночам мучает совесть. Хочется сделать новую ветку, в которой от старого ничего, даже README. Тоже самое с проектированием — итерации рулят. Можно идти сверху, но если сверху идти очень сложно и абстрактно для человеческого разума, начинают снизу. Совместное проектирование за чашкой кофе или максимально формализованное. Если некому помочь — можно помочь самому себе, правой или левой рукой, как вы больше любите. Описываем, сохраняем всё и возвращаемся через неделю. Трезвый взгляд помогает, уверен Стив.

В этой же главе дальше идёт критика проектирования и крайне полезная литература, которую никто не будет читать.

## Глава 6. Классы

Наконец-то, господа. Ведь классы, это что-то связанное с кодом, да? Если вы пишите серъезный код на Java и C++ то вам стоит прочитать эту главу, но скорее всего вы используете более детальную и современную систему соблюдения качества кода, основанную на этих принципах. 

Самое интересное начинается с самого абстрактного: абстрактных типов данных (Abstract data type). Когда клиентский код, который пользуется этим типом данных не управляет и не контролирует многие из внутренних состояний и условий, то код, скрытый в реализациии АТД легко оптимизировать и расширять, значительно сократив вероятность breaking changes. Поэтому и придуманы интерфейсы и всё такое прочее. В этой главное расписывается, что это такое, зачем они нужны и чем руководствоваться чтобы понять, что не так в написанном интерфейсе. 

*Выражайте в интерфейсе класса согласованный уровень абстракции.* Мне нравится эта фраза, ей можно отвечать на любой вопрос вообще любому человеку любого пола. 

В главе куча примеров. _Спросите себя: «Что представляет этот стек, список или эта очередь?» Если стек представляет набор сотрудников, рассматривайте АТД как набор сотрудников, а
не как стек._ Абстракция, формируемая этими методами, относится к уровню «employee» (сотрудник).

    void AddEmployee( Employee employee );
    void RemoveEmployee( Employee employee );
   
Абстракция, формируемая этими методами, относится к уровню «list» (список).

    Employee NextItemInList();
    Employee FirstItem();

Здесь `ListContainer` смешивается с `Employers`. Поэтому лучше — разносить. Надо понимать реализации какой абстракции является класс. 

*Инкапсулируйте*, говорит нам книга с таким примером:

    float x;
    float y;
    float z;
   
Так просто объявить переменные наружу? Это нарушает инкапсуляцию, потому что клиентский код может свободно делать с данными Point что угодно, при этом сам класс может даже не узнать об их изменении. В общем для C++ это бы выглядело как-то так (и да, обязательно надо покрыть это документацией, как шутят в энтерпрайзе):

    float GetX();
    float GetY();
    float GetZ();
    void SetX( float x );
    void SetY( float y );
    void SetZ( float z );

Торжество геттеров и сеттеров. 

Интерфейсы полезны, употребляйте их почаще. *Минимизируйте доступность классов и методов.* И так далее. И тому подобное. Предоставьте, что вы разрабатываете большое SDK. И посмотрите на хорошие примеры. И даже книга не понадобится.  

Дальше идут описания вещей, больше свойственных ООП. Интересно, что звучит это очень логично и зачастую поддается статическому анализу, но есть вещи, которые понятны и очевидны только человеку. Это снова про то, что не стоит смешивать абстракции разных уровней, стек и список сотрудников, например. И пошли-поехали советы:

Не «переопределяйте» непереопределяемые методы. 

Убедитесь, что вы наследуете только то, что хотите наследовать. (Или лучше _вообще не наследовать_)

Перемещайте общие интерфейсы, данные и формы поведения на как можно более высокий уровень иерархии наследования. (Или лучше _вообще не наследовать_)

С подозрением относитесь к классам, объекты которых создаются в единственном экземпляре.

С подозрением относитесь к базовым классам, имеющим только один производный класс.

<blockquote>
Пример. С подозрением относитесь к классам, которые переопределяют метод,
оставляя его пустым Как правило, это говорит о неудачном проектировании
базового класса. Допустим, вы создали класс Cat, включающий метод Scratch()
(царапать), но после обнаружили, что некоторые коты лишены когтей и не могут
царапаться. Вы могли бы унаследовать от класса Cat класс ScratchlessCat, переоп#
ределив в нем метод Scratch() так, чтобы он ничего не делал. Однако этот подход
связан с рядом проблем.
Он нарушает абстракцию (контракт интерфейса) класса Cat, изменяя семан#
тику его интерфейса.
При расширении на другие производные классы этот подход быстро стано#
вится неуправляемым. Что будет, когда вы найдете кота без хвоста? Или кота,
который не ловит мышей? Или кота, который не пьет молоко? В итоге у вас
могут появиться производные классы вроде ScratchlessTaillessMicelessMilklessCat.
Код, написанный по этой методике, трудно сопровождать, потому что со вре#
менем поведение производных классов начинает сильно отличаться от интер#
фейсов и форм поведения базовых классов.
Исправлять эту проблему следует не в базовом классе, а в первоначальном классе
Cat. Создайте класс Claws (когти) и включите его в класс Cats. Корень наших бед
— предположение, что все коты царапаются; предложенный способ позволит
устранить причину проблемы, а не бороться с ее следствиями.

...

Вообще минимизируйте сотрудничество класса с другими классами Старайтесь свести к минимуму все следующие показатели:
число видов создаваемых объектов;
число непосредственно вызываемых методов созданных объектов;
число вызовов методов, принадлежащих объектам, возвращенным другими
созданными объектами.
</blockquote>

В качестве вывода приводятся 100 и 1 причина, почему классы стоит создавать, просто потому что классы выступают в роли всего вообще. Ни одной причины, зачем создавать алгебраический тип данных, например, и понятно почему, но в сущности их легко выделить оттуда. И если есть модульность и типы данных, то отсуствие классических классов из этой главы не помешает написать совершенный код. 


Глава 7. Высококачественные методы

Наши “высококачественные методы” 18 лет на рынке интернета, изготовлены из прекрасного и чистого кода на php и на каждый метод имеется своя лицензия от РосДжаваМетодНадзора. Гарантия 3 года. 

Здесь и далее я бы хотел заменить `метод` на `функция`, но не могу. 

Как определяется качество метода? Ну, по большей части это то, зачем придумали линтеры, а также разных смысловых метрик, типа плохого названия, не отражающего суть метода, или заветного числа 7 (не должно быть больше семи входных параметров и семи условных операций внутри).

На языках вроде Haskell большая часть рекомендаций соблюдается by design, а всякие современные IDE/плагины к редакторам позволяют контролировать сложность методов, не говоря уже о форматировании.

_Зачем нужен метод класса?_ Самый простой ответ в том, что метод в императивных языках нужно создавать, чтобы документировать код. Иногда эта причина перевешивает все остальные аргументы и функция может быть создана для одной строки. Второй главный принцип DRY (Do not Repeat Yourself), то есть элементарно не повторяться. Во многих больших проектов, первый принцип — читаемость кода — куда важнее любых других. В чистых функциональных языках, я бы добавил, что принципы разделения на функции диктует ещё и сама концепция.

Стив расказывает про функциональную связность (Сohesion). Цель в том, чтобы достигнуть сильной связности функции, т.е. выполнения только функцией только одной задачи. Например, косинус - это функция сильной связности. В реальном мире функции обычно сложнее, поэтому выделяют несколько видов связности,  [wiki:Cohesion](http://en.wikipedia.org/wiki/Cohesion_(computer_science). Советую почитать про связность побольше, интересная концепция оценки и контролирования сложности методов. 

Далее идет описание того, что есть “удачное имя метода”. В том числе из этой книги. Современные IDE позволяют в автокомплит, поэтому можно написать три символа, остальные двадцать восемь добьет редактор. Но всё же, хорошие методы без побочных эффектов несложно назвать правильно без использования 10 слов подряд. 

Объем метода, его параметры — их порядок, количество, именование. Все эти рекомендации наверняка есть в вашем code conventions. Поищите. Но в общем и целом в этой главе приведены некоторые исследования о увеличении количества ошибок в методах более 200 строк. Ясно-понятно, разный синтаксис языков и годы публикаций делят это число на ноль и требования могут быть другими.

Плохо когда метод использует глобальные переменные. Макросы следует использовать только в крайнем случае. 

