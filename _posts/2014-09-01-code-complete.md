---
layout: post
title: Совершенный код, ч.1 
---
# {{page.title}}

_Макконнелл С. - Code Complete_

Сразу скажу — я горячий сторонник всяких пишикодблять.рф. Есть спортивное программирование, когда пацанчики на спорте ебашат задачи, используя знания алгоритмов и математики, они как турникомены, с 6 лет делают вечерний выход силы и утренний подъем с переворотом. Есть хакерство — когда задачи реальные, а правил, в общем-то нет, кроме чести — эти ребята якобы не знают слова невозможно. А вот дяди, которые потеют за то, чтобы у них регулярно, два раза в месяц, обновлялись цифры в базе данных платежных систем они — промышленные программисты. А по вечерам, когда едут домой, слушая подкасты, смотрят в запотевшее окно, и мечтают о том, как сделают библиотеку с тысячью звездочками на гитхабе.

За время, которое можно потратить на чтение этой книги можно развернуть 5 сайтов на вордпресс или объявить около 20 фабрик. 

И что мне не нравится в таких книгах, это когда я вижу вот такой скриншот: (страница 25, рис. 1). А он тут в самом начале. Он навевает скуку. 

Однако, уже второй рисунок всё меняет. Кодирование и отладка! В конце концов, у Стива Макконнелла чувствуется боль, которую невозможно заглушить маленькой книжечкой, поэтому он написал здоровенный тяжелый кирпич, которым можно было бы приговорить плохого программиста на месте.

## Глава 2

Первая осмысленная глава — вторая. “Метафоры, позволяющие лучше понять разработку ПО”. Сначала метафора — литературная, она описывает, конечно, в какой-то мере небольшие проекты: сел такой и написал код. Но он никогда не будет законченным, в отличие от книги. ОТКАЗАТЬ. Та метафора, в которой софт это взращивание картошки, включая подготовку, поливку, прополку, удобрения и очень многие этапы — сельскохозяйственная. Есть опасность начать говорить про то что “надо проредить проект” и “сдобрить его новыми библиотеками”. Я не могу повлиять на картошку напрямую, тогда как на код могу и поэтому ОТКАЗАТЬ. Фантазия людей неограничена и следующим выступает метафора жемчужины. Инкрементная разработка наращиванием. Сначала создаем скелет, прототип, потом начинаем по слоям. Фред Брукс “Мифический человеко-месяц”. ДОБРО. Самая популярная метафора, которая даже есть на башорге, это строительная. Очень много аналогий. Хотите перенести стену? Тратится время рабочих на перепроектировку. Что-то можно поменять уже в построенном доме, сделать капитальный ремонт. Но зачастую проще построить новый дом. И никто не будет создавать вещи, которые можно купить (стиральную машину, базу данных, шкаф, фреймворк), только если это не индивидуальный, особенный проект. ДОБРО.

Но как обычно, мир не черный и белый (на самом деле такой), а 50 оттенков серого. Комибинируйте метафоры, меняйте их, пользуйтесь этими эфристически аналогиями.

Эта вторая глава мне не понравилась как раз заключением, оно как бы извиняется, простите, что толку от этого почти нет, главное это посыл — не можешь обьяснить напрямую, пользуйся аналогиями, понятными собеседнику.

Глава 3. Про предварительные усвловия.

Глава открывается поговоркой про плотников Measure Twice, Cut Once. В русской версии книги это уже “семь раз отмерь — один раз отрежь”. В индийской я бы назвал “отмеряй, пока не сотрется метр”. И как важно, как важно соблюдать все эти условия.
В наш век на первый план выходит софт, написанный за выпитыми литрами кофе ночью, создается впечатление, что вся эта штука с проектированием — суета. Конечно, ведь 90% рынка софта остается за пределами видимости среднего уличного кодера. От NASA до медицины, там не так.

Люди не знакомые с разработкой ПО могут болеть синдромом WISCA: «Why Isn’t Sam Coding Anything? (Почему Сэм не пишет код?)». Тут на помощь приходят метафоры. Стройка ещё не началась, даже фундамент — все сидят и чертят планы здания и всё согласуют! Поэтому автор приводит пару аргументов: обращение к логике, обращение к аналогиям, обращение к статистики из прошлого. Чем раньше исправляется ошибка, тем дешевле это стоит. 

А теперь снова моя нелюбимая часть “всё зависит от проекта”. Конечно, К.О. Пишешь сайты, то тебе даже Стив советует “нечеткую спецификацию требований”. Ни предварительное проектирование, ни комбинация итеративного подхода к исправлению ошибок не может дать однозначных гарантий, но всё-таки для большинства типов проектов можно вывести какие-то рекомендации. 

Затем эти формулизованные требования якобы должны понять. Все рекоменндации вкратце звучат так “Суть предварительных условий конструирования в том, что вам следует сначала определить, какие из них уместны для вашего проекта.”

(скриншот пирамиды)
Первое — это определение проблемы. Не решения, а проблемы. Чувствуете разницу? Если плохо сформуровать проблему, можно потратить время, решая не ту.
Второе — требования. Не программистом, а заказчиком. 
Требования подобны воде. Опи-
раться на них легче, если они
заморожены.
Аноним

Затем идут советы. Когда читаешь такие советы не видишь противоречий. Но и откровений тоже. Но если у вас в проекте постоянно меняются требования посмотрите страницу 39. Там даже приведен контрольный список вопросов. Типа “можно ли провести независимое тестирование, которое определит что выполнены все требования”. 


В описании правильной архитектуры сквозит ООП подход. Классы, методы. Стандартные слова, что GUI должен быть GUI, масштабирование, безопасность и всё такое.

Глава 4. Конструирование

Вот есть требования. И что дальше? Выбор языков программирования. Это смешно. Фразы в духе “если опыт с языком три года, эффективность выше на 30%”. Фразы — для руководителей. Особенно мне понравилась таблица на странице 60. 

Пример такой: если писал всю жизнь на Fortran, то и на C++ будешь писать также, перенеся туда всю свою быдлячью деревенскую сущность. Описание языков тоже довольно устаревшие, зато “старая школа”. Не забыть про конвекцию. И снова на помощь приходит метафора “одна часть картины в стиле импрессиониста, другая в классическом, третья в кубическом? что получится в итоге”. А в итоге получится шедевр.

Какой софт купить, какую платформу выбрать и еще 100 вопросов, которые кажутся очевидными. Составить анкету и следовать ей — это корпоративный стиль. Представьте себе разработку операционной системы для x-box. Представьте себе программные комплексы в самолете. Ну и наконец, какой-нибудь Netflix. Вот когда вас будет десять человек с многолетним опытом, чтобы спроектировать систему — тогда вам может и пригодится этот список. Так закончилась эта невзрачная часть. 

Часть II Высококачественный код
Глава 5 Проектирование при конструировании
Грязная проблема — проблема, которая возникает при частичном или полном решении другой проблемы. Иногда приходится что-то сделать, чтобы понять что надо сделать, чтобы в итоге решить задачу. Проектирование недетерминировано, связано с ограничениями, и, наконец, вывод — проектирование это эвристический процесс. Дальше идет такая скукота, что мне пришлось поставить три будильника, но я всё равно заснул. Система делится на подсистемы, те делятся на классы, а потом на методы. ВОТ ЭТО ДА.
Но с другой стороны, чем больше явных деталей собраны вместе в этой главе, тем легче выровнять средний опыт читателей. Представьте что каждому из них задан вопрос “как делать софт?”. Каждый вспомнит процентов 60% из этой главы. Поэтому вот вам 100%, читайте и запоминайте.
Манипулируйте абстракциями, смело кидайте инкапсуляции в лицо всем объектам, живите композицией. Абстракция говорит: «Вы можете рассмотреть объект с общей точки зрения». Инкапсуляция добавляет: «Более того, вы не можете рассмотреть объект с иной точки зрения»
Снова ничего полезного. Меня разочаровывает эта глава. Она слишком привязана к ООП. “Используйте наследование, если оно облегчает проектирование”. Полиморфизм? 
Сокрытие информации - вот важный столб эвристического программирования. Вместо id = ++ currentID вы пишете метод NewID() и он возвращает вам всё, как вы пожелаете. Выделите области, которые меняются и изолируйте их:


Бизнес правила
Зависимости от оборудования
Ввод вывод
Нестандартные возможности языка
Сложные аспекты проектирования и конструирования

Нужно уменшать сопряжение (не связанность, это другое), которое бывает нескольких видов (через объект, параметры, семантичекое). И вот тут реально хорошие примеры приведены. 
Используйте шаблоны проектирования, шаблоны известные всем. Это выиграет вам 10 минут на интервью, в течение которых HR поставит вам две галочки. (скриншот). 
Формализуйте контракты классов, проектируйте систему для тестирования. Затем следуют два разных совета. Один звучит как “избегайте неудач” (спасибо!), а второй “тщательно выбирайте время связывания” (binding time). Если в коде есть x = 3, то чем позже будет x=3, тем лучше. Я тоже за pure functional way, чтобы это не значило!

Когда написал что-то, хочется переписать заново (только не этот пост), чтобы стало лучше. Многое на своей шкуре почувствал, понял где вляпался и по ночам мучает совесть. Хочется сделать новый бранч, в котором нет ничего от старого, даже README.  Тоже самое с проектированием — итерации рулят. Можно идти сверху, но если сверху идти очень сложно и абстрактно, начинают снизу. Или прототипирование. Совместное проектирование за чашкой кофе или максимально формализованное. Если некому помочь — можно помочь самому себе, правой или левой рукой, как вы больше любите. Описываем, сохраняем всё и возвращаемся через неделю. Трезвый взгляд помогает.
В этой же главе критика проектирования и и крайне полезная литература.

Глава 6

Наконец-то господа. Наконец-то. Начинается самое интересное. Самое интересное начинается с самого абстрактного: абстрактных типов данных (Abstract data type). Всякие графы, мапы, хэши, стеки и прочее. Независимо от того, императивный или функциональный стиль.

Выражайте в интерфейсе класса согласованный уровень абстракции

Абстракция, формируемая этими методами, относится к уровню «employee» (сотрудник).
 void AddEmployee( Employee employee );
 void RemoveEmployee( Employee employee );
Абстракция, формируемая этими методами, относится к уровню «list» (список).
 Employee NextItemInList();
 Employee FirstItem();

Здесь ListContainer смешивается с Employers. Поэтому лучше — разносить. Надо понимать реализации какой абстракции является класс. 
Инкапсулируйте говорит нам книга с таким примером:
float x;
float y;
float z;
нарушает инкапсуляцию, потому что клиентский код может свободно делать с
данными Point что угодно, при этом сам класс может даже не узнать об их изме#
нении (Riel, 1996). В то же время класс Point, включающий члены:
float GetX();
float GetY();
float GetZ();
void SetX( float x );
void SetY( float y );
void SetZ( float z );

Чувствуете C++ прошлого тысячелетия? Наверное, мне досталось старая версия книги или много занудства. Как же от этого тошнит. Но в общем и целом, это правда. Интерфейсы полезны, употребляйте их почаще. Минимизируйте доступность классов и методов. И так далее. И тому подобное. Предоставьте, что вы разрабатываете большое SDK. И посмотрите на хорошие примеры.
Не «переопределяйте» непереопределяемые методы'члены. 
Убедитесь, что вы наследуете только то, что хотите наследовать.
Перемещайте общие интерфейсы, данные и формы поведения на как можно более высокий уровень иерархии наследования.
С подозрением относитесь к классам, объекты которых создаются в единственном экземпляре.
С подозрением относитесь к базовым классам, имеющим только один производный класс

Пример. С подозрением относитесь к классам, которые переопределяют метод,
оставляя его пустым Как правило, это говорит о неудачном проектировании
базового класса. Допустим, вы создали класс Cat, включающий метод Scratch()
(царапать), но после обнаружили, что некоторые коты лишены когтей и не могут
царапаться. Вы могли бы унаследовать от класса Cat класс ScratchlessCat, переоп#
ределив в нем метод Scratch() так, чтобы он ничего не делал. Однако этот подход
связан с рядом проблем.
Он нарушает абстракцию (контракт интерфейса) класса Cat, изменяя семан#
тику его интерфейса.
При расширении на другие производные классы этот подход быстро стано#
вится неуправляемым. Что будет, когда вы найдете кота без хвоста? Или кота,
который не ловит мышей? Или кота, который не пьет молоко? В итоге у вас
могут появиться производные классы вроде ScratchlessTaillessMicelessMilklessCat.
Код, написанный по этой методике, трудно сопровождать, потому что со вре#
менем поведение производных классов начинает сильно отличаться от интер#
фейсов и форм поведения базовых классов.
Исправлять эту проблему следует не в базовом классе, а в первоначальном классе
Cat. Создайте класс Claws (когти) и включите его в класс Cats. Корень наших бед
— предположение, что все коты царапаются; предложенный способ позволит
устранить причину проблемы, а не бороться с ее следствиями.

Вообще минимизируйте сотрудничество класса с другими классами Старайтесь свести к минимуму все следующие показатели:
число видов создаваемых объектов;
число непосредственно вызываемых методов созданных объектов;
число вызовов методов, принадлежащих объектам, возвращенным другими
созданными объектами.

Резюме причин создания класса
Вот список разумных причин создания класса:
моделирование объектов реального мира;
моделирование абстрактных объектов;
снижение сложности;
изоляция сложности;
сокрытие деталей реализации;
ограничение влияния изменений;
сокрытие глобальных данных;
упрощение передачи параметров в методы;
создание центральных точек управления;
облегчение повторного использования кода;
планирование создания семейства программ;
упаковка родственных операцией;
выполнение специфического вида рефакторинга.


Глава 7. Высококачественные методы

Что это ещё за ерунда, “высококачественные методы”? Это всё, начиная от плохо названного метода, когда название ниочем не говорит, до заветного числа 7 (не должно быть больше семи входных параметров и семи операций). На языках вроде Haskell большая часть рекомендаций соблюдается by design. Ну и вообще современные языки вкупе с современными IDE позволяют легко контролировать сложность методов, не говоря о форматировании. Например, любой линтер, статический анализатор (или какая-нибудь IDEA и Visual Studio) предупредит о неиспользуемых переменных и тому подобных вещах, которые приведены в главе.
Метод в императивных языках нужно создавать, чтобы документировать код. И соблюдать принцип DRY. В книге об этом не сказано, но в ФП всё немного по другому. Иммутабельные чистые функции пишутся там сами. Мемоизация, легкость отладки, ну и просто сама концепция заставляет.
Далее идет “удачное имя метода”, При функциональном связывании, когда один метод - одна функция. Я понял откуда все эти длинные названия в корпоративных системах. В том числе из этой книги. Современные IDE позволяют автокомплит, поэтому можно написать три символа, остальные двадцать добьет редактор.
Объем метода, его параметры. Все эти рекомендации есть в вашем code conventions. Поищите.
Когда использовать функцию а когда процедуру? Ответа тоже нет. Используйте функцию, если это функция.

